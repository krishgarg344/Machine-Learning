# -*- coding: utf-8 -*-
"""3014_lab6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Hy7-49N_vkj6PiEUnlGu2u8tP0A6Leyv
"""

import numpy as np
import pandas as pd
from sklearn.metrics import classification_report
from sklearn.model_selection import train_test_split
from sklearn import svm

df = pd.read_csv('adult.csv')
df.head(10)

df.info()

df.shape

df.isnull().sum().sum()

df.drop_duplicates(inplace=True)

df.drop(columns=['education', 'fnlwgt', 'workclass', 'occupation'], inplace=True)

df.shape

print(df['native.country'].nunique())

print(df['native.country'].unique())

# doing grouping of countries to reduce no. of features after one hot encoding
country_map = {
    'United-States': 'North-America',
    'Mexico': 'North-America',
    'Canada': 'North-America',
    'Puerto-Rico': 'North-America',
    'El-Salvador': 'North-America',
    'Cuba': 'North-America',
    'Jamaica': 'North-America',
    'Dominican-Republic': 'North-America',
    'Guatemala': 'North-America',
    'Haiti': 'North-America',
    'Honduras': 'North-America',
    'Nicaragua': 'North-America',
    'Trinadad&Tobago': 'North-America',
    'Outlying-US(Guam-USVI-etc)': 'North-America',

    'Philippines': 'Asia',
    'India': 'Asia',
    'China': 'Asia',
    'Vietnam': 'Asia',
    'Japan': 'Asia',
    'Taiwan': 'Asia',
    'Iran': 'Asia',
    'Hong': 'Asia',
    'Thailand': 'Asia',
    'Cambodia': 'Asia',
    'Laos': 'Asia',

    'Germany': 'Europe',
    'England': 'Europe',
    'Italy': 'Europe',
    'Poland': 'Europe',
    'Portugal': 'Europe',
    'Greece': 'Europe',
    'Ireland': 'Europe',
    'France': 'Europe',
    'Hungary': 'Europe',
    'Scotland': 'Europe',
    'Yugoslavia': 'Europe',
    'Holand-Netherlands': 'Europe',

    'South': 'Latin-America',
    'Columbia': 'Latin-America',
    'Ecuador': 'Latin-America',
    'Peru': 'Latin-America',

    '?': 'Other'}

# Applying the mapping. Any country not in the map will also become 'Other'
df['native.country'] = df['native.country'].map(country_map).fillna('Other')

for col in df.columns:
  if df[col].dtype == 'object':
    df = pd.get_dummies(df, columns=[col], dtype=int, drop_first=True)

df.shape

df.head()

y = df['income_>50K']
X = df.drop(columns='income_>50K')
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

#model=SVC(kernel='linear')
from sklearn.svm import SVC
h1 = SVC(random_state=42, max_iter=5000)
h1.fit(X_train,y_train)
h1.score(X_train,y_train)

h1.support_vectors_

y_pred=h1.predict(X_test)
pd.crosstab(y_test,y_pred)

print(classification_report(y_test,y_pred))

import numpy as np
import matplotlib.pyplot as plt
from sklearn import svm, datasets

wine = datasets.load_wine()
X = wine.data[:, :2]
y = wine.target

# Training the SVC model
# Usinging linear kernel for simpler visualization of decision boundary and support vectors
svc = svm.SVC(kernel='linear', C=1.0)
svc.fit(X, y)

X.shape

# Get the support vectors
support_vectors = svc.support_vectors_

# Create a mesh to plot the decision boundary
x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1
y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.02),
                     np.arange(y_min, y_max, 0.02))

# Plotting the decision boundary
Z = svc.predict(np.c_[xx.ravel(), yy.ravel()])#convert a multi-dimensional array into a one-dimensional (flattened) array. I
print(Z)

Z = Z.reshape(xx.shape)
print(Z)

plt.contourf(xx, yy, Z, cmap=plt.cm.coolwarm, alpha=0.8)

np.c_[xx.ravel(), yy.ravel()] #creating a 2D array from two 2D arrays, xx and yy, typically generated by np.meshgrid.

Z

xx.shape

yy.shape

plt.contourf(xx, yy, Z, cmap=plt.cm.coolwarm, alpha=0.8)
# Ploting the data points
plt.scatter(X[:, 0], X[:, 1], c=y, cmap=plt.cm.coolwarm, edgecolors='k')

# Plotting support vectors
plt.contourf(xx, yy, Z, cmap=plt.cm.coolwarm, alpha=0.8)
plt.scatter(support_vectors[:, 0], support_vectors[:, 1], s=100,
            facecolors='none', edgecolors='g', linewidths=2, label='Support Vectors')

plt.xlabel('Sepal length')
plt.ylabel('Sepal width')
plt.title('SVC with Support Vectors')
plt.legend()
plt.show()

